{"version":3,"sources":["webpack:///./src/views/ES6/childCpns/03String.vue?fa60","webpack:///src/views/ES6/childCpns/03String.vue","webpack:///./src/views/ES6/childCpns/03String.vue?0e71","webpack:///./src/views/ES6/childCpns/03String.vue"],"names":["render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","staticClass","_v","name","component"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAsBH,EAAII,MAAMC,GAAO,OAAOL,EAAIM,GAAG,IACnGC,EAAkB,CAAC,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBE,EAAGL,EAAII,MAAMC,IAAIH,EAAG,OAAOG,EAAG,MAAM,CAACG,YAAY,aAAa,CAACH,EAAG,MAAM,CAACL,EAAIS,GAAG,iqbAA+pbJ,EAAG,MAAM,CAACL,EAAIS,GAAG,4xPCowB/0b,GACEC,KAAM,YCtwBwW,I,YCO5WC,EAAY,eACd,EACAZ,EACAQ,GACA,EACA,KACA,WACA,MAIa,aAAAI,E","file":"js/chunk-2d0c0711.712aff30.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"03-string\"},[_c('pre',[_vm._v(\"\\r\\n  字符串的扩展\\r\\n\\r\\n  字符的 Unicode 表示法\\r\\n  ES6 加强了对 Unicode 的支持，允许采用\\\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。\\r\\n\\r\\n  \\\"\\\\u0061\\\"\\r\\n  // \\\"a\\\"\\r\\n  但是，这种表示法只限于码点在\\\\u0000~\\\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\r\\n\\r\\n  \\\"\\\\uD842\\\\uDFB7\\\"\\r\\n  // \\\"𠮷\\\"\\r\\n\\r\\n  \\\"\\\\u20BB7\\\"\\r\\n  // \\\" 7\\\"\\r\\n  上面代码表示，如果直接在\\\\u后面跟上超过0xFFFF的数值（比如\\\\u20BB7），JavaScript 会理解成\\\\u20BB+7。由于\\\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。\\r\\n\\r\\n  ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。\\r\\n\\r\\n  \\\"\\\\u{20BB7}\\\"\\r\\n  // \\\"𠮷\\\"\\r\\n\\r\\n  \\\"\\\\u{41}\\\\u{42}\\\\u{43}\\\"\\r\\n  // \\\"ABC\\\"\\r\\n\\r\\n  let hello = 123;\\r\\n  hell\\\\u{6F} // 123\\r\\n\\r\\n  '\\\\u{1F680}' === '\\\\uD83D\\\\uDE80'\\r\\n  // true\\r\\n  上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。\\r\\n\\r\\n  有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。\\r\\n\\r\\n  '\\\\z' === 'z'  // true\\r\\n  '\\\\172' === 'z' // true\\r\\n  '\\\\x7A' === 'z' // true\\r\\n  '\\\\u007A' === 'z' // true\\r\\n  '\\\\u{7A}' === 'z' // true\\r\\n  字符串的遍历器接口\\r\\n  ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。\\r\\n\\r\\n  for (let codePoint of 'foo') {\\r\\n    console.log(codePoint)\\r\\n  }\\r\\n  // \\\"f\\\"\\r\\n  // \\\"o\\\"\\r\\n  // \\\"o\\\"\\r\\n  除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。\\r\\n\\r\\n  let text = String.fromCodePoint(0x20BB7);\\r\\n\\r\\n  for (let i = 0; i < text.length; i++) {\\r\\n    console.log(text[i]);\\r\\n  }\\r\\n  // \\\" \\\"\\r\\n  // \\\" \\\"\\r\\n\\r\\n  for (let i of text) {\\r\\n    console.log(i);\\r\\n  }\\r\\n  // \\\"𠮷\\\"\\r\\n  上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。\\r\\n\\r\\n  直接输入 U+2028 和 U+2029\\r\\n  JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\\\u4e2d，两者是等价的。\\r\\n\\r\\n  '中' === '\\\\u4e2d' // true\\r\\n  但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。\\r\\n\\r\\n  U+005C：反斜杠（reverse solidus)\\r\\n  U+000D：回车（carriage return）\\r\\n  U+2028：行分隔符（line separator）\\r\\n  U+2029：段分隔符（paragraph separator）\\r\\n  U+000A：换行符（line feed）\\r\\n  举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\\\\\\\\或者\\\\u005c。\\r\\n\\r\\n  这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被JSON.parse解析，就有可能直接报错。\\r\\n\\r\\n  const json = '\\\"\\\\u2028\\\"';\\r\\n  JSON.parse(json); // 可能报错\\r\\n  JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。\\r\\n\\r\\n  const PS = eval(\\\"'\\\\u2029'\\\");\\r\\n  根据这个提案，上面的代码不会报错。\\r\\n\\r\\n  注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。\\r\\n\\r\\n  JSON.stringify() 的改造\\r\\n  根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。\\r\\n\\r\\n  具体来说，UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\\\uD834\\\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\\\uD834和\\\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\\\uDF06\\\\uD834并没有对应的字符。\\r\\n\\r\\n  JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。\\r\\n\\r\\n  JSON.stringify('\\\\u{D834}') // \\\"\\\\u{D834}\\\"\\r\\n  为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\\r\\n\\r\\n  JSON.stringify('\\\\u{D834}') // \\\"\\\"\\\\\\\\uD834\\\"\\\"\\r\\n  JSON.stringify('\\\\uDF06\\\\uD834') // \\\"\\\"\\\\\\\\udf06\\\\\\\\ud834\\\"\\\"\\r\\n  模板字符串\\r\\n  传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。\\r\\n\\r\\n  $('#result').append(\\r\\n    'There are <b>' + basket.count + '</b> ' +\\r\\n    'items in your basket, ' +\\r\\n    '<em>' + basket.onSale +\\r\\n    '</em> are on sale!'\\r\\n  );\\r\\n  上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\\r\\n\\r\\n  $('#result').append(`\\r\\n    There are <b>${basket.count}</b> items\\r\\n    in your basket, <em>${basket.onSale}</em>\\r\\n    are on sale!\\r\\n  `);\\r\\n  模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\\r\\n\\r\\n  // 普通字符串\\r\\n  `In JavaScript '\\\\n' is a line-feed.`\\r\\n\\r\\n  // 多行字符串\\r\\n  `In JavaScript this is\\r\\n  not legal.`\\r\\n\\r\\n  console.log(`string text line 1\\r\\n  string text line 2`);\\r\\n\\r\\n  // 字符串中嵌入变量\\r\\n  let name = \\\"Bob\\\", time = \\\"today\\\";\\r\\n  `Hello ${name}, how are you ${time}?`\\r\\n  上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\\r\\n\\r\\n  let greeting = `\\\\`Yo\\\\` World!`;\\r\\n  如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\\r\\n\\r\\n  $('#list').html(`\\r\\n  <ul>\\r\\n    <li>first</li>\\r\\n    <li>second</li>\\r\\n  </ul>\\r\\n  `);\\r\\n  上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。\\r\\n\\r\\n  $('#list').html(`\\r\\n  <ul>\\r\\n    <li>first</li>\\r\\n    <li>second</li>\\r\\n  </ul>\\r\\n  `.trim());\\r\\n  模板字符串中嵌入变量，需要将变量名写在${}之中。\\r\\n\\r\\n  function authorize(user, action) {\\r\\n    if (!user.hasPrivilege(action)) {\\r\\n      throw new Error(\\r\\n        // 传统写法为\\r\\n        // 'User '\\r\\n        // + user.name\\r\\n        // + ' is not authorized to do '\\r\\n        // + action\\r\\n        // + '.'\\r\\n        `User ${user.name} is not authorized to do ${action}.`);\\r\\n    }\\r\\n  }\\r\\n  大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\\r\\n\\r\\n  let x = 1;\\r\\n  let y = 2;\\r\\n\\r\\n  `${x} + ${y} = ${x + y}`\\r\\n  // \\\"1 + 2 = 3\\\"\\r\\n\\r\\n  `${x} + ${y * 2} = ${x + y * 2}`\\r\\n  // \\\"1 + 4 = 5\\\"\\r\\n\\r\\n  let obj = {x: 1, y: 2};\\r\\n  `${obj.x + obj.y}`\\r\\n  // \\\"3\\\"\\r\\n  模板字符串之中还能调用函数。\\r\\n\\r\\n  function fn() {\\r\\n    return \\\"Hello World\\\";\\r\\n  }\\r\\n\\r\\n  `foo ${fn()} bar`\\r\\n  // foo Hello World bar\\r\\n  如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。\\r\\n\\r\\n  如果模板字符串中的变量没有声明，将报错。\\r\\n\\r\\n  // 变量place没有声明\\r\\n  let msg = `Hello, ${place}`;\\r\\n  // 报错\\r\\n  由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。\\r\\n\\r\\n  `Hello ${'World'}`\\r\\n  // \\\"Hello World\\\"\\r\\n  模板字符串甚至还能嵌套。\\r\\n\\r\\n  const tmpl = addrs => `\\r\\n    <table>\\r\\n    ${addrs.map(addr => `\\r\\n      <tr><td>${addr.first}</td></tr>\\r\\n      <tr><td>${addr.last}</td></tr>\\r\\n    `).join('')}\\r\\n    </table>\\r\\n  `;\\r\\n  上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。\\r\\n\\r\\n  const data = [\\r\\n      { first: '<Jane>', last: 'Bond' },\\r\\n      { first: 'Lars', last: '<Croft>' },\\r\\n  ];\\r\\n\\r\\n  console.log(tmpl(data));\\r\\n  // <table>\\r\\n  //\\r\\n  //   <tr><td><Jane></td></tr>\\r\\n  //   <tr><td>Bond</td></tr>\\r\\n  //\\r\\n  //   <tr><td>Lars</td></tr>\\r\\n  //   <tr><td><Croft></td></tr>\\r\\n  //\\r\\n  // </table>\\r\\n  如果需要引用模板字符串本身，在需要时执行，可以写成函数。\\r\\n\\r\\n  let func = (name) => `Hello ${name}!`;\\r\\n  func('Jack') // \\\"Hello Jack!\\\"\\r\\n  上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。\\r\\n\\r\\n  实例：模板编译\\r\\n  下面，我们来看一个通过模板字符串，生成正式模板的实例。\\r\\n\\r\\n  let template = `\\r\\n  <ul>\\r\\n    <% for(let i=0; i < data.supplies.length; i++) { %>\\r\\n      <li><%= data.supplies[i] %></li>\\r\\n    <% } %>\\r\\n  </ul>\\r\\n  `;\\r\\n  上面代码在模板字符串之中，放置了一个常规模板。该模板使用<<%...%>放置 JavaScript 代码，使用<<%= ... %>输出 JavaScript 表达式。\\r\\n\\r\\n  怎么编译这个模板字符串呢？\\r\\n\\r\\n  一种思路是将其转换为 JavaScript 表达式字符串。\\r\\n\\r\\n  echo('<ul>');\\r\\n  for(let i=0; i < data.supplies.length; i++) {\\r\\n    echo('<li>');\\r\\n    echo(data.supplies[i]);\\r\\n    echo('</li>');\\r\\n  };\\r\\n  echo('</ul>');\\r\\n  这个转换使用正则表达式就行了。\\r\\n\\r\\n  let evalExpr = /<%=(.+?)%>/g;\\r\\n  let expr = /<%([\\\\s\\\\S]+?)%>/g;\\r\\n\\r\\n  template = template\\r\\n    .replace(evalExpr, '`); \\\\n  echo( $1 ); \\\\n  echo(`')\\r\\n    .replace(expr, '`); \\\\n $1 \\\\n  echo(`');\\r\\n\\r\\n  template = 'echo(`' + template + '`);';\\r\\n  然后，将template封装在一个函数里面返回，就可以了。\\r\\n\\r\\n  let script =\\r\\n  `(function parse(data){\\r\\n    let output = \\\"\\\";\\r\\n\\r\\n    function echo(html){\\r\\n      output += html;\\r\\n    }\\r\\n\\r\\n    ${ template }\\r\\n\\r\\n    return output;\\r\\n  })`;\\r\\n\\r\\n  return script;\\r\\n  将上面的内容拼装成一个模板编译函数compile。\\r\\n\\r\\n  function compile(template){\\r\\n    const evalExpr = /<%=(.+?)%>/g;\\r\\n    const expr = /<%([\\\\s\\\\S]+?)%>/g;\\r\\n\\r\\n    template = template\\r\\n      .replace(evalExpr, '`); \\\\n  echo( $1 ); \\\\n  echo(`')\\r\\n      .replace(expr, '`); \\\\n $1 \\\\n  echo(`');\\r\\n\\r\\n    template = 'echo(`' + template + '`);';\\r\\n\\r\\n    let script =\\r\\n    `(function parse(data){\\r\\n      let output = \\\"\\\";\\r\\n\\r\\n      function echo(html){\\r\\n        output += html;\\r\\n      }\\r\\n\\r\\n      ${ template }\\r\\n\\r\\n      return output;\\r\\n    })`;\\r\\n\\r\\n    return script;\\r\\n  }\\r\\n  compile函数的用法如下。\\r\\n\\r\\n  let parse = eval(compile(template));\\r\\n  div.innerHTML = parse({ supplies: [ \\\"broom\\\", \\\"mop\\\", \\\"cleaner\\\" ] });\\r\\n  //   <ul>\\r\\n  //     <li>broom</li>\\r\\n  //     <li>mop</li>\\r\\n  //     <li>cleaner</li>\\r\\n  //   </ul>\\r\\n  标签模板\\r\\n  模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。\\r\\n\\r\\n  alert`hello`\\r\\n  // 等同于\\r\\n  alert(['hello'])\\r\\n  标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\\r\\n\\r\\n  但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\\r\\n\\r\\n  let a = 5;\\r\\n  let b = 10;\\r\\n\\r\\n  tag`Hello ${ a + b } world ${ a * b }`;\\r\\n  // 等同于\\r\\n  tag(['Hello ', ' world ', ''], 15, 50);\\r\\n  上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。\\r\\n\\r\\n  函数tag依次会接收到多个参数。\\r\\n\\r\\n  function tag(stringArr, value1, value2){\\r\\n    // ...\\r\\n  }\\r\\n\\r\\n  // 等同于\\r\\n\\r\\n  function tag(stringArr, ...values){\\r\\n    // ...\\r\\n  }\\r\\n  tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。\\r\\n\\r\\n  tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。\\r\\n\\r\\n  tag函数所有参数的实际值如下。\\r\\n\\r\\n  第一个参数：['Hello ', ' world ', '']\\r\\n  第二个参数: 15\\r\\n  第三个参数：50\\r\\n  也就是说，tag函数实际上以下面的形式调用。\\r\\n\\r\\n  tag(['Hello ', ' world ', ''], 15, 50)\\r\\n  我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。\\r\\n\\r\\n  let a = 5;\\r\\n  let b = 10;\\r\\n\\r\\n  function tag(s, v1, v2) {\\r\\n    console.log(s[0]);\\r\\n    console.log(s[1]);\\r\\n    console.log(s[2]);\\r\\n    console.log(v1);\\r\\n    console.log(v2);\\r\\n\\r\\n    return \\\"OK\\\";\\r\\n  }\\r\\n\\r\\n  tag`Hello ${ a + b } world ${ a * b}`;\\r\\n  // \\\"Hello \\\"\\r\\n  // \\\" world \\\"\\r\\n  // \\\"\\\"\\r\\n  // 15\\r\\n  // 50\\r\\n  // \\\"OK\\\"\\r\\n  下面是一个更复杂的例子。\\r\\n\\r\\n  let total = 30;\\r\\n  let msg = passthru`The total is ${total} (${total*1.05} with tax)`;\\r\\n\\r\\n  function passthru(literals) {\\r\\n    let result = '';\\r\\n    let i = 0;\\r\\n\\r\\n    while (i < literals.length) {\\r\\n      result += literals[i++];\\r\\n      if (i < arguments.length) {\\r\\n        result += arguments[i];\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  msg // \\\"The total is 30 (31.5 with tax)\\\"\\r\\n  上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。\\r\\n\\r\\n  passthru函数采用 rest 参数的写法如下。\\r\\n\\r\\n  function passthru(literals, ...values) {\\r\\n    let output = \\\"\\\";\\r\\n    let index;\\r\\n    for (index = 0; index < values.length; index++) {\\r\\n      output += literals[index] + values[index];\\r\\n    }\\r\\n\\r\\n    output += literals[index]\\r\\n    return output;\\r\\n  }\\r\\n  “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。\\r\\n\\r\\n  let message =\\r\\n    SaferHTML`<p>${sender} has sent you a message.</p>`;\\r\\n\\r\\n  function SaferHTML(templateData) {\\r\\n    let s = templateData[0];\\r\\n    for (let i = 1; i < arguments.length; i++) {\\r\\n      let arg = String(arguments[i]);\\r\\n\\r\\n      // Escape special characters in the substitution.\\r\\n      s += arg.replace(/&/g, \\\"&\\\")\\r\\n              .replace(/</g, \\\"<\\\")\\r\\n              .replace(/>/g, \\\">\\\");\\r\\n\\r\\n      // Don't escape special characters in the template.\\r\\n      s += templateData[i];\\r\\n    }\\r\\n    return s;\\r\\n  }\\r\\n  上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。\\r\\n\\r\\n  let sender = '<script>alert(\\\"abc\\\")</script>'; // 恶意代码\\r\\n  let message = SaferHTML`<p>${sender} has sent you a message.</p>`;\\r\\n\\r\\n  message\\r\\n  // <p><script>alert(\\\"abc\\\")</script> has sent you a message.</p>\\r\\n  标签模板的另一个应用，就是多语言转换（国际化处理）。\\r\\n\\r\\n  i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`\\r\\n  // \\\"欢迎访问xxx，您是第xxxx位访问者！\\\"\\r\\n  模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。\\r\\n\\r\\n  // 下面的hashTemplate函数\\r\\n  // 是一个自定义的模板处理函数\\r\\n  let libraryHtml = hashTemplate`\\r\\n    <ul>\\r\\n      #for book in ${myBooks}\\r\\n        <li><i>#{book.title}</i> by #{book.author}</li>\\r\\n      #end\\r\\n    </ul>\\r\\n  `;\\r\\n  除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。\\r\\n\\r\\n  jsx`\\r\\n    <div>\\r\\n      <input\\r\\n        ref='input'\\r\\n        onChange='${this.handleChange}'\\r\\n        defaultValue='${this.state.value}' />\\r\\n        ${this.state.value}\\r\\n    </div>\\r\\n  `\\r\\n  上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到jsx函数的具体实现。\\r\\n\\r\\n  下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。\\r\\n\\r\\n  java`\\r\\n  class HelloWorldApp {\\r\\n    public static void main(String[] args) {\\r\\n      System.out.println(\\\"Hello World!\\\"); // Display the string.\\r\\n    }\\r\\n  }\\r\\n  `\\r\\n  HelloWorldApp.main();\\r\\n  模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。\\r\\n\\r\\n  console.log`123`\\r\\n  // [\\\"123\\\", raw: Array[1]]\\r\\n  上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。\\r\\n\\r\\n  请看下面的例子。\\r\\n\\r\\n  tag`First line\\\\nSecond line`\\r\\n\\r\\n  function tag(strings) {\\r\\n    console.log(strings.raw[0]);\\r\\n    // strings.raw[0] 为 \\\"First line\\\\\\\\nSecond line\\\"\\r\\n    // 打印输出 \\\"First line\\\\nSecond line\\\"\\r\\n  }\\r\\n  上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[\\\"First line\\\\nSecond line\\\"]，那么strings.raw数组就是[\\\"First line\\\\\\\\nSecond line\\\"]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\\\n视为\\\\\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\\r\\n\\r\\n  模板字符串的限制\\r\\n  前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。\\r\\n\\r\\n  举例来说，标签模板里面可以嵌入 LaTEX 语言。\\r\\n\\r\\n  function latex(strings) {\\r\\n    // ...\\r\\n  }\\r\\n\\r\\n  let document = latex`\\r\\n  \\\\newcommand{\\\\fun}{\\\\textbf{Fun!}}  // 正常工作\\r\\n  \\\\newcommand{\\\\unicode}{\\\\textbf{Unicode!}} // 报错\\r\\n  \\\\newcommand{\\\\xerxes}{\\\\textbf{King!}} // 报错\\r\\n\\r\\n  Breve over the h goes \\\\u{h}ere // 报错\\r\\n  `\\r\\n  上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。\\r\\n\\r\\n  模板字符串会将\\\\u00FF和\\\\u{42}当作 Unicode 字符进行转义，所以\\\\unicode解析时报错；而\\\\x56会被当作十六进制字符串转义，所以\\\\xerxes会报错。也就是说，\\\\u和\\\\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。\\r\\n\\r\\n  为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。\\r\\n\\r\\n  function tag(strs) {\\r\\n    strs[0] === undefined\\r\\n    strs.raw[0] === \\\"\\\\\\\\unicode and \\\\\\\\u{55}\\\";\\r\\n  }\\r\\n  tag`\\\\unicode and \\\\u{55}`\\r\\n  上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。\\r\\n\\r\\n  注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。\\r\\n\\r\\n  let bad = `bad escape sequence: \\\\unicode`; // 报错\\r\\n\")]),_c('pre',[_vm._v(\"\\r\\n  字符串的新增方法\\r\\n  String.fromCodePoint()\\r\\n  String.raw()\\r\\n  实例方法：codePointAt()\\r\\n  实例方法：normalize()\\r\\n  实例方法：includes(), startsWith(), endsWith()\\r\\n  实例方法：repeat()\\r\\n  实例方法：padStart()，padEnd()\\r\\n  实例方法：trimStart()，trimEnd()\\r\\n  实例方法：matchAll()\\r\\n  【免费课程】开始学习《ES6 实战教程》，一线大厂前端必备技能。\\r\\n  本章介绍字符串对象的新增方法。\\r\\n\\r\\n  String.fromCodePoint()\\r\\n  ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。\\r\\n\\r\\n  String.fromCharCode(0x20BB7)\\r\\n  // \\\"ஷ\\\"\\r\\n  上面代码中，String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。\\r\\n\\r\\n  ES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。\\r\\n\\r\\n  String.fromCodePoint(0x20BB7)\\r\\n  // \\\"𠮷\\\"\\r\\n  String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\\\uD83D\\\\uDE80y'\\r\\n  // true\\r\\n  上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。\\r\\n\\r\\n  注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。\\r\\n\\r\\n  String.raw()\\r\\n  ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\\r\\n\\r\\n  String.raw`Hi\\\\n${2+3}!`\\r\\n  // 实际返回 \\\"Hi\\\\\\\\n5!\\\"，显示的是转义后的结果 \\\"Hi\\\\n5!\\\"\\r\\n\\r\\n  String.raw`Hi\\\\u000A!`;\\r\\n  // 实际返回 \\\"Hi\\\\\\\\u000A!\\\"，显示的是转义后的结果 \\\"Hi\\\\u000A!\\\"\\r\\n  如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。\\r\\n\\r\\n  String.raw`Hi\\\\\\\\n`\\r\\n  // 返回 \\\"Hi\\\\\\\\\\\\\\\\n\\\"\\r\\n\\r\\n  String.raw`Hi\\\\\\\\n` === \\\"Hi\\\\\\\\\\\\\\\\n\\\" // true\\r\\n  String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\\r\\n\\r\\n  String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。\\r\\n\\r\\n  // `foo${1 + 2}bar`\\r\\n  // 等同于\\r\\n  String.raw({ raw: ['foo', 'bar'] }, 1 + 2) // \\\"foo3bar\\\"\\r\\n  上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。\\r\\n\\r\\n  作为函数，String.raw()的代码实现基本如下。\\r\\n\\r\\n  String.raw = function (strings, ...values) {\\r\\n    let output = '';\\r\\n    let index;\\r\\n    for (index = 0; index < values.length; index++) {\\r\\n      output += strings.raw[index] + values[index];\\r\\n    }\\r\\n\\r\\n    output += strings.raw[index]\\r\\n    return output;\\r\\n  }\\r\\n  实例方法：codePointAt()\\r\\n  JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。\\r\\n\\r\\n  var s = \\\"𠮷\\\";\\r\\n\\r\\n  s.length // 2\\r\\n  s.charAt(0) // ''\\r\\n  s.charAt(1) // ''\\r\\n  s.charCodeAt(0) // 55362\\r\\n  s.charCodeAt(1) // 57271\\r\\n  上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。\\r\\n\\r\\n  ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\\r\\n\\r\\n  let s = '𠮷a';\\r\\n\\r\\n  s.codePointAt(0) // 134071\\r\\n  s.codePointAt(1) // 57271\\r\\n\\r\\n  s.codePointAt(2) // 97\\r\\n  codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。\\r\\n\\r\\n  总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。\\r\\n\\r\\n  codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。\\r\\n\\r\\n  let s = '𠮷a';\\r\\n\\r\\n  s.codePointAt(0).toString(16) // \\\"20bb7\\\"\\r\\n  s.codePointAt(2).toString(16) // \\\"61\\\"\\r\\n  你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。\\r\\n\\r\\n  let s = '𠮷a';\\r\\n  for (let ch of s) {\\r\\n    console.log(ch.codePointAt(0).toString(16));\\r\\n  }\\r\\n  // 20bb7\\r\\n  // 61\\r\\n  另一种方法也可以，使用扩展运算符（...）进行展开运算。\\r\\n\\r\\n  let arr = [...'𠮷a']; // arr.length === 2\\r\\n  arr.forEach(\\r\\n    ch => console.log(ch.codePointAt(0).toString(16))\\r\\n  );\\r\\n  // 20bb7\\r\\n  // 61\\r\\n  codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。\\r\\n\\r\\n  function is32Bit(c) {\\r\\n    return c.codePointAt(0) > 0xFFFF;\\r\\n  }\\r\\n\\r\\n  is32Bit(\\\"𠮷\\\") // true\\r\\n  is32Bit(\\\"a\\\") // false\\r\\n  实例方法：normalize()\\r\\n  许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\\\u004F）和ˇ（\\\\u030C）合成Ǒ（\\\\u004F\\\\u030C）。\\r\\n\\r\\n  这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。\\r\\n\\r\\n  '\\\\u01D1'==='\\\\u004F\\\\u030C' //false\\r\\n\\r\\n  '\\\\u01D1'.length // 1\\r\\n  '\\\\u004F\\\\u030C'.length // 2\\r\\n  上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。\\r\\n\\r\\n  ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\\r\\n\\r\\n  '\\\\u01D1'.normalize() === '\\\\u004F\\\\u030C'.normalize()\\r\\n  // true\\r\\n  normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。\\r\\n\\r\\n  NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。\\r\\n  NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。\\r\\n  NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）\\r\\n  NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。\\r\\n  '\\\\u004F\\\\u030C'.normalize('NFC').length // 1\\r\\n  '\\\\u004F\\\\u030C'.normalize('NFD').length // 2\\r\\n  上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。\\r\\n\\r\\n  不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。\\r\\n\\r\\n  实例方法：includes(), startsWith(), endsWith()\\r\\n  传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\\r\\n\\r\\n  includes()：返回布尔值，表示是否找到了参数字符串。\\r\\n  startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\\r\\n  endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\\r\\n  let s = 'Hello world!';\\r\\n\\r\\n  s.startsWith('Hello') // true\\r\\n  s.endsWith('!') // true\\r\\n  s.includes('o') // true\\r\\n  这三个方法都支持第二个参数，表示开始搜索的位置。\\r\\n\\r\\n  let s = 'Hello world!';\\r\\n\\r\\n  s.startsWith('world', 6) // true\\r\\n  s.endsWith('Hello', 5) // true\\r\\n  s.includes('Hello', 6) // false\\r\\n  上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\\r\\n\\r\\n  实例方法：repeat()\\r\\n  repeat方法返回一个新字符串，表示将原字符串重复n次。\\r\\n\\r\\n  'x'.repeat(3) // \\\"xxx\\\"\\r\\n  'hello'.repeat(2) // \\\"hellohello\\\"\\r\\n  'na'.repeat(0) // \\\"\\\"\\r\\n  参数如果是小数，会被取整。\\r\\n\\r\\n  'na'.repeat(2.9) // \\\"nana\\\"\\r\\n  如果repeat的参数是负数或者Infinity，会报错。\\r\\n\\r\\n  'na'.repeat(Infinity)\\r\\n  // RangeError\\r\\n  'na'.repeat(-1)\\r\\n  // RangeError\\r\\n  但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。\\r\\n\\r\\n  'na'.repeat(-0.9) // \\\"\\\"\\r\\n  参数NaN等同于 0。\\r\\n\\r\\n  'na'.repeat(NaN) // \\\"\\\"\\r\\n  如果repeat的参数是字符串，则会先转换成数字。\\r\\n\\r\\n  'na'.repeat('na') // \\\"\\\"\\r\\n  'na'.repeat('3') // \\\"nanana\\\"\\r\\n  实例方法：padStart()，padEnd()\\r\\n  ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。\\r\\n\\r\\n  'x'.padStart(5, 'ab') // 'ababx'\\r\\n  'x'.padStart(4, 'ab') // 'abax'\\r\\n\\r\\n  'x'.padEnd(5, 'ab') // 'xabab'\\r\\n  'x'.padEnd(4, 'ab') // 'xaba'\\r\\n  上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。\\r\\n\\r\\n  如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。\\r\\n\\r\\n  'xxx'.padStart(2, 'ab') // 'xxx'\\r\\n  'xxx'.padEnd(2, 'ab') // 'xxx'\\r\\n  如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。\\r\\n\\r\\n  'abc'.padStart(10, '0123456789')\\r\\n  // '0123456abc'\\r\\n  如果省略第二个参数，默认使用空格补全长度。\\r\\n\\r\\n  'x'.padStart(4) // '   x'\\r\\n  'x'.padEnd(4) // 'x   '\\r\\n  padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。\\r\\n\\r\\n  '1'.padStart(10, '0') // \\\"0000000001\\\"\\r\\n  '12'.padStart(10, '0') // \\\"0000000012\\\"\\r\\n  '123456'.padStart(10, '0') // \\\"0000123456\\\"\\r\\n  另一个用途是提示字符串格式。\\r\\n\\r\\n  '12'.padStart(10, 'YYYY-MM-DD') // \\\"YYYY-MM-12\\\"\\r\\n  '09-12'.padStart(10, 'YYYY-MM-DD') // \\\"YYYY-09-12\\\"\\r\\n  实例方法：trimStart()，trimEnd()\\r\\n  ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\\r\\n\\r\\n  const s = '  abc  ';\\r\\n\\r\\n  s.trim() // \\\"abc\\\"\\r\\n  s.trimStart() // \\\"abc  \\\"\\r\\n  s.trimEnd() // \\\"  abc\\\"\\r\\n  上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。\\r\\n\\r\\n  除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。\\r\\n\\r\\n  浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。\\r\\n\\r\\n  实例方法：matchAll()\\r\\n  matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。\\r\\n\")])])}]\n\nexport { render, staticRenderFns }","<template>\r\n<div class=\"03-string\">\r\n<pre>\r\n  字符串的扩展\r\n\r\n  字符的 Unicode 表示法\r\n  ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。\r\n\r\n  \"\\u0061\"\r\n  // \"a\"\r\n  但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\r\n\r\n  \"\\uD842\\uDFB7\"\r\n  // \"𠮷\"\r\n\r\n  \"\\u20BB7\"\r\n  // \" 7\"\r\n  上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。\r\n\r\n  ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。\r\n\r\n  \"\\u{20BB7}\"\r\n  // \"𠮷\"\r\n\r\n  \"\\u{41}\\u{42}\\u{43}\"\r\n  // \"ABC\"\r\n\r\n  let hello = 123;\r\n  hell\\u{6F} // 123\r\n\r\n  '\\u{1F680}' === '\\uD83D\\uDE80'\r\n  // true\r\n  上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。\r\n\r\n  有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。\r\n\r\n  '\\z' === 'z'  // true\r\n  '\\172' === 'z' // true\r\n  '\\x7A' === 'z' // true\r\n  '\\u007A' === 'z' // true\r\n  '\\u{7A}' === 'z' // true\r\n  字符串的遍历器接口\r\n  ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。\r\n\r\n  for (let codePoint of 'foo') {\r\n    console.log(codePoint)\r\n  }\r\n  // \"f\"\r\n  // \"o\"\r\n  // \"o\"\r\n  除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。\r\n\r\n  let text = String.fromCodePoint(0x20BB7);\r\n\r\n  for (let i = 0; i &lt; text.length; i++) {\r\n    console.log(text[i]);\r\n  }\r\n  // \" \"\r\n  // \" \"\r\n\r\n  for (let i of text) {\r\n    console.log(i);\r\n  }\r\n  // \"𠮷\"\r\n  上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。\r\n\r\n  直接输入 U+2028 和 U+2029\r\n  JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\u4e2d，两者是等价的。\r\n\r\n  '中' === '\\u4e2d' // true\r\n  但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。\r\n\r\n  U+005C：反斜杠（reverse solidus)\r\n  U+000D：回车（carriage return）\r\n  U+2028：行分隔符（line separator）\r\n  U+2029：段分隔符（paragraph separator）\r\n  U+000A：换行符（line feed）\r\n  举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\\\\或者\\u005c。\r\n\r\n  这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被JSON.parse解析，就有可能直接报错。\r\n\r\n  const json = '\"\\u2028\"';\r\n  JSON.parse(json); // 可能报错\r\n  JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。\r\n\r\n  const PS = eval(\"'\\u2029'\");\r\n  根据这个提案，上面的代码不会报错。\r\n\r\n  注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。\r\n\r\n  JSON.stringify() 的改造\r\n  根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。\r\n\r\n  具体来说，UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。\r\n\r\n  JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。\r\n\r\n  JSON.stringify('\\u{D834}') // \"\\u{D834}\"\r\n  为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\r\n\r\n  JSON.stringify('\\u{D834}') // \"\"\\\\uD834\"\"\r\n  JSON.stringify('\\uDF06\\uD834') // \"\"\\\\udf06\\\\ud834\"\"\r\n  模板字符串\r\n  传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。\r\n\r\n  $('#result').append(\r\n    'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' +\r\n    'items in your basket, ' +\r\n    '&lt;em&gt;' + basket.onSale +\r\n    '&lt;/em&gt; are on sale!'\r\n  );\r\n  上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\r\n\r\n  $('#result').append(`\r\n    There are &lt;b&gt;${basket.count}&lt;/b&gt; items\r\n    in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;\r\n    are on sale!\r\n  `);\r\n  模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\r\n\r\n  // 普通字符串\r\n  `In JavaScript '\\n' is a line-feed.`\r\n\r\n  // 多行字符串\r\n  `In JavaScript this is\r\n  not legal.`\r\n\r\n  console.log(`string text line 1\r\n  string text line 2`);\r\n\r\n  // 字符串中嵌入变量\r\n  let name = \"Bob\", time = \"today\";\r\n  `Hello ${name}, how are you ${time}?`\r\n  上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\r\n\r\n  let greeting = `\\`Yo\\` World!`;\r\n  如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\r\n\r\n  $('#list').html(`\r\n  &lt;ul&gt;\r\n    &lt;li&gt;first&lt;/li&gt;\r\n    &lt;li&gt;second&lt;/li&gt;\r\n  &lt;/ul&gt;\r\n  `);\r\n  上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。\r\n\r\n  $('#list').html(`\r\n  &lt;ul&gt;\r\n    &lt;li&gt;first&lt;/li&gt;\r\n    &lt;li&gt;second&lt;/li&gt;\r\n  &lt;/ul&gt;\r\n  `.trim());\r\n  模板字符串中嵌入变量，需要将变量名写在${}之中。\r\n\r\n  function authorize(user, action) {\r\n    if (!user.hasPrivilege(action)) {\r\n      throw new Error(\r\n        // 传统写法为\r\n        // 'User '\r\n        // + user.name\r\n        // + ' is not authorized to do '\r\n        // + action\r\n        // + '.'\r\n        `User ${user.name} is not authorized to do ${action}.`);\r\n    }\r\n  }\r\n  大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\r\n\r\n  let x = 1;\r\n  let y = 2;\r\n\r\n  `${x} + ${y} = ${x + y}`\r\n  // \"1 + 2 = 3\"\r\n\r\n  `${x} + ${y * 2} = ${x + y * 2}`\r\n  // \"1 + 4 = 5\"\r\n\r\n  let obj = {x: 1, y: 2};\r\n  `${obj.x + obj.y}`\r\n  // \"3\"\r\n  模板字符串之中还能调用函数。\r\n\r\n  function fn() {\r\n    return \"Hello World\";\r\n  }\r\n\r\n  `foo ${fn()} bar`\r\n  // foo Hello World bar\r\n  如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。\r\n\r\n  如果模板字符串中的变量没有声明，将报错。\r\n\r\n  // 变量place没有声明\r\n  let msg = `Hello, ${place}`;\r\n  // 报错\r\n  由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。\r\n\r\n  `Hello ${'World'}`\r\n  // \"Hello World\"\r\n  模板字符串甚至还能嵌套。\r\n\r\n  const tmpl = addrs =&gt; `\r\n    &lt;table&gt;\r\n    ${addrs.map(addr =&gt; `\r\n      &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;\r\n      &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;\r\n    `).join('')}\r\n    &lt;/table&gt;\r\n  `;\r\n  上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。\r\n\r\n  const data = [\r\n      { first: '&lt;Jane&gt;', last: 'Bond' },\r\n      { first: 'Lars', last: '&lt;Croft&gt;' },\r\n  ];\r\n\r\n  console.log(tmpl(data));\r\n  // &lt;table&gt;\r\n  //\r\n  //   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;\r\n  //   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;\r\n  //\r\n  //   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;\r\n  //   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;\r\n  //\r\n  // &lt;/table&gt;\r\n  如果需要引用模板字符串本身，在需要时执行，可以写成函数。\r\n\r\n  let func = (name) =&gt; `Hello ${name}!`;\r\n  func('Jack') // \"Hello Jack!\"\r\n  上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。\r\n\r\n  实例：模板编译\r\n  下面，我们来看一个通过模板字符串，生成正式模板的实例。\r\n\r\n  let template = `\r\n  &lt;ul&gt;\r\n    &lt;% for(let i=0; i &lt; data.supplies.length; i++) { %&gt;\r\n      &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;\r\n    &lt;% } %&gt;\r\n  &lt;/ul&gt;\r\n  `;\r\n  上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;&lt;%...%&gt;放置 JavaScript 代码，使用&lt;&lt;%= ... %&gt;输出 JavaScript 表达式。\r\n\r\n  怎么编译这个模板字符串呢？\r\n\r\n  一种思路是将其转换为 JavaScript 表达式字符串。\r\n\r\n  echo('&lt;ul&gt;');\r\n  for(let i=0; i &lt; data.supplies.length; i++) {\r\n    echo('&lt;li&gt;');\r\n    echo(data.supplies[i]);\r\n    echo('&lt;/li&gt;');\r\n  };\r\n  echo('&lt;/ul&gt;');\r\n  这个转换使用正则表达式就行了。\r\n\r\n  let evalExpr = /&lt;%=(.+?)%&gt;/g;\r\n  let expr = /&lt;%([\\s\\S]+?)%&gt;/g;\r\n\r\n  template = template\r\n    .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\r\n    .replace(expr, '`); \\n $1 \\n  echo(`');\r\n\r\n  template = 'echo(`' + template + '`);';\r\n  然后，将template封装在一个函数里面返回，就可以了。\r\n\r\n  let script =\r\n  `(function parse(data){\r\n    let output = \"\";\r\n\r\n    function echo(html){\r\n      output += html;\r\n    }\r\n\r\n    ${ template }\r\n\r\n    return output;\r\n  })`;\r\n\r\n  return script;\r\n  将上面的内容拼装成一个模板编译函数compile。\r\n\r\n  function compile(template){\r\n    const evalExpr = /&lt;%=(.+?)%&gt;/g;\r\n    const expr = /&lt;%([\\s\\S]+?)%&gt;/g;\r\n\r\n    template = template\r\n      .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\r\n      .replace(expr, '`); \\n $1 \\n  echo(`');\r\n\r\n    template = 'echo(`' + template + '`);';\r\n\r\n    let script =\r\n    `(function parse(data){\r\n      let output = \"\";\r\n\r\n      function echo(html){\r\n        output += html;\r\n      }\r\n\r\n      ${ template }\r\n\r\n      return output;\r\n    })`;\r\n\r\n    return script;\r\n  }\r\n  compile函数的用法如下。\r\n\r\n  let parse = eval(compile(template));\r\n  div.innerHTML = parse({ supplies: [ \"broom\", \"mop\", \"cleaner\" ] });\r\n  //   &lt;ul&gt;\r\n  //     &lt;li&gt;broom&lt;/li&gt;\r\n  //     &lt;li&gt;mop&lt;/li&gt;\r\n  //     &lt;li&gt;cleaner&lt;/li&gt;\r\n  //   &lt;/ul&gt;\r\n  标签模板\r\n  模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。\r\n\r\n  alert`hello`\r\n  // 等同于\r\n  alert(['hello'])\r\n  标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\r\n\r\n  但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\r\n\r\n  let a = 5;\r\n  let b = 10;\r\n\r\n  tag`Hello ${ a + b } world ${ a * b }`;\r\n  // 等同于\r\n  tag(['Hello ', ' world ', ''], 15, 50);\r\n  上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。\r\n\r\n  函数tag依次会接收到多个参数。\r\n\r\n  function tag(stringArr, value1, value2){\r\n    // ...\r\n  }\r\n\r\n  // 等同于\r\n\r\n  function tag(stringArr, ...values){\r\n    // ...\r\n  }\r\n  tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。\r\n\r\n  tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。\r\n\r\n  tag函数所有参数的实际值如下。\r\n\r\n  第一个参数：['Hello ', ' world ', '']\r\n  第二个参数: 15\r\n  第三个参数：50\r\n  也就是说，tag函数实际上以下面的形式调用。\r\n\r\n  tag(['Hello ', ' world ', ''], 15, 50)\r\n  我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。\r\n\r\n  let a = 5;\r\n  let b = 10;\r\n\r\n  function tag(s, v1, v2) {\r\n    console.log(s[0]);\r\n    console.log(s[1]);\r\n    console.log(s[2]);\r\n    console.log(v1);\r\n    console.log(v2);\r\n\r\n    return \"OK\";\r\n  }\r\n\r\n  tag`Hello ${ a + b } world ${ a * b}`;\r\n  // \"Hello \"\r\n  // \" world \"\r\n  // \"\"\r\n  // 15\r\n  // 50\r\n  // \"OK\"\r\n  下面是一个更复杂的例子。\r\n\r\n  let total = 30;\r\n  let msg = passthru`The total is ${total} (${total*1.05} with tax)`;\r\n\r\n  function passthru(literals) {\r\n    let result = '';\r\n    let i = 0;\r\n\r\n    while (i &lt; literals.length) {\r\n      result += literals[i++];\r\n      if (i &lt; arguments.length) {\r\n        result += arguments[i];\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  msg // \"The total is 30 (31.5 with tax)\"\r\n  上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。\r\n\r\n  passthru函数采用 rest 参数的写法如下。\r\n\r\n  function passthru(literals, ...values) {\r\n    let output = \"\";\r\n    let index;\r\n    for (index = 0; index &lt; values.length; index++) {\r\n      output += literals[index] + values[index];\r\n    }\r\n\r\n    output += literals[index]\r\n    return output;\r\n  }\r\n  “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。\r\n\r\n  let message =\r\n    SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;\r\n\r\n  function SaferHTML(templateData) {\r\n    let s = templateData[0];\r\n    for (let i = 1; i &lt; arguments.length; i++) {\r\n      let arg = String(arguments[i]);\r\n\r\n      // Escape special characters in the substitution.\r\n      s += arg.replace(/&amp;/g, \"&amp;\")\r\n              .replace(/&lt;/g, \"&lt;\")\r\n              .replace(/&gt;/g, \"&gt;\");\r\n\r\n      // Don't escape special characters in the template.\r\n      s += templateData[i];\r\n    }\r\n    return s;\r\n  }\r\n  上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。\r\n\r\n  let sender = '&lt;script&gt;alert(\"abc\")&lt;/script&gt;'; // 恶意代码\r\n  let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;\r\n\r\n  message\r\n  // &lt;p&gt;&lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message.&lt;/p&gt;\r\n  标签模板的另一个应用，就是多语言转换（国际化处理）。\r\n\r\n  i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`\r\n  // \"欢迎访问xxx，您是第xxxx位访问者！\"\r\n  模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。\r\n\r\n  // 下面的hashTemplate函数\r\n  // 是一个自定义的模板处理函数\r\n  let libraryHtml = hashTemplate`\r\n    &lt;ul&gt;\r\n      #for book in ${myBooks}\r\n        &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt;\r\n      #end\r\n    &lt;/ul&gt;\r\n  `;\r\n  除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。\r\n\r\n  jsx`\r\n    &lt;div&gt;\r\n      &lt;input\r\n        ref='input'\r\n        onChange='${this.handleChange}'\r\n        defaultValue='${this.state.value}' /&gt;\r\n        ${this.state.value}\r\n    &lt;/div&gt;\r\n  `\r\n  上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到jsx函数的具体实现。\r\n\r\n  下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。\r\n\r\n  java`\r\n  class HelloWorldApp {\r\n    public static void main(String[] args) {\r\n      System.out.println(\"Hello World!\"); // Display the string.\r\n    }\r\n  }\r\n  `\r\n  HelloWorldApp.main();\r\n  模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。\r\n\r\n  console.log`123`\r\n  // [\"123\", raw: Array[1]]\r\n  上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。\r\n\r\n  请看下面的例子。\r\n\r\n  tag`First line\\nSecond line`\r\n\r\n  function tag(strings) {\r\n    console.log(strings.raw[0]);\r\n    // strings.raw[0] 为 \"First line\\\\nSecond line\"\r\n    // 打印输出 \"First line\\nSecond line\"\r\n  }\r\n  上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[\"First line\\nSecond line\"]，那么strings.raw数组就是[\"First line\\\\nSecond line\"]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\r\n\r\n  模板字符串的限制\r\n  前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。\r\n\r\n  举例来说，标签模板里面可以嵌入 LaTEX 语言。\r\n\r\n  function latex(strings) {\r\n    // ...\r\n  }\r\n\r\n  let document = latex`\r\n  \\newcommand{\\fun}{\\textbf{Fun!}}  // 正常工作\r\n  \\newcommand{\\unicode}{\\textbf{Unicode!}} // 报错\r\n  \\newcommand{\\xerxes}{\\textbf{King!}} // 报错\r\n\r\n  Breve over the h goes \\u{h}ere // 报错\r\n  `\r\n  上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。\r\n\r\n  模板字符串会将\\u00FF和\\u{42}当作 Unicode 字符进行转义，所以\\unicode解析时报错；而\\x56会被当作十六进制字符串转义，所以\\xerxes会报错。也就是说，\\u和\\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。\r\n\r\n  为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。\r\n\r\n  function tag(strs) {\r\n    strs[0] === undefined\r\n    strs.raw[0] === \"\\\\unicode and \\\\u{55}\";\r\n  }\r\n  tag`\\unicode and \\u{55}`\r\n  上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。\r\n\r\n  注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。\r\n\r\n  let bad = `bad escape sequence: \\unicode`; // 报错\r\n</pre>\r\n<pre>\r\n  字符串的新增方法\r\n  String.fromCodePoint()\r\n  String.raw()\r\n  实例方法：codePointAt()\r\n  实例方法：normalize()\r\n  实例方法：includes(), startsWith(), endsWith()\r\n  实例方法：repeat()\r\n  实例方法：padStart()，padEnd()\r\n  实例方法：trimStart()，trimEnd()\r\n  实例方法：matchAll()\r\n  【免费课程】开始学习《ES6 实战教程》，一线大厂前端必备技能。\r\n  本章介绍字符串对象的新增方法。\r\n\r\n  String.fromCodePoint()\r\n  ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。\r\n\r\n  String.fromCharCode(0x20BB7)\r\n  // \"ஷ\"\r\n  上面代码中，String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。\r\n\r\n  ES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。\r\n\r\n  String.fromCodePoint(0x20BB7)\r\n  // \"𠮷\"\r\n  String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'\r\n  // true\r\n  上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。\r\n\r\n  注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。\r\n\r\n  String.raw()\r\n  ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\r\n\r\n  String.raw`Hi\\n${2+3}!`\r\n  // 实际返回 \"Hi\\\\n5!\"，显示的是转义后的结果 \"Hi\\n5!\"\r\n\r\n  String.raw`Hi\\u000A!`;\r\n  // 实际返回 \"Hi\\\\u000A!\"，显示的是转义后的结果 \"Hi\\u000A!\"\r\n  如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。\r\n\r\n  String.raw`Hi\\\\n`\r\n  // 返回 \"Hi\\\\\\\\n\"\r\n\r\n  String.raw`Hi\\\\n` === \"Hi\\\\\\\\n\" // true\r\n  String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\r\n\r\n  String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。\r\n\r\n  // `foo${1 + 2}bar`\r\n  // 等同于\r\n  String.raw({ raw: ['foo', 'bar'] }, 1 + 2) // \"foo3bar\"\r\n  上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。\r\n\r\n  作为函数，String.raw()的代码实现基本如下。\r\n\r\n  String.raw = function (strings, ...values) {\r\n    let output = '';\r\n    let index;\r\n    for (index = 0; index &lt; values.length; index++) {\r\n      output += strings.raw[index] + values[index];\r\n    }\r\n\r\n    output += strings.raw[index]\r\n    return output;\r\n  }\r\n  实例方法：codePointAt()\r\n  JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。\r\n\r\n  var s = \"𠮷\";\r\n\r\n  s.length // 2\r\n  s.charAt(0) // ''\r\n  s.charAt(1) // ''\r\n  s.charCodeAt(0) // 55362\r\n  s.charCodeAt(1) // 57271\r\n  上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。\r\n\r\n  ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\r\n\r\n  let s = '𠮷a';\r\n\r\n  s.codePointAt(0) // 134071\r\n  s.codePointAt(1) // 57271\r\n\r\n  s.codePointAt(2) // 97\r\n  codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。\r\n\r\n  总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。\r\n\r\n  codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。\r\n\r\n  let s = '𠮷a';\r\n\r\n  s.codePointAt(0).toString(16) // \"20bb7\"\r\n  s.codePointAt(2).toString(16) // \"61\"\r\n  你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。\r\n\r\n  let s = '𠮷a';\r\n  for (let ch of s) {\r\n    console.log(ch.codePointAt(0).toString(16));\r\n  }\r\n  // 20bb7\r\n  // 61\r\n  另一种方法也可以，使用扩展运算符（...）进行展开运算。\r\n\r\n  let arr = [...'𠮷a']; // arr.length === 2\r\n  arr.forEach(\r\n    ch =&gt; console.log(ch.codePointAt(0).toString(16))\r\n  );\r\n  // 20bb7\r\n  // 61\r\n  codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。\r\n\r\n  function is32Bit(c) {\r\n    return c.codePointAt(0) &gt; 0xFFFF;\r\n  }\r\n\r\n  is32Bit(\"𠮷\") // true\r\n  is32Bit(\"a\") // false\r\n  实例方法：normalize()\r\n  许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。\r\n\r\n  这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。\r\n\r\n  '\\u01D1'==='\\u004F\\u030C' //false\r\n\r\n  '\\u01D1'.length // 1\r\n  '\\u004F\\u030C'.length // 2\r\n  上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。\r\n\r\n  ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\r\n\r\n  '\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()\r\n  // true\r\n  normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。\r\n\r\n  NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。\r\n  NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。\r\n  NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）\r\n  NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。\r\n  '\\u004F\\u030C'.normalize('NFC').length // 1\r\n  '\\u004F\\u030C'.normalize('NFD').length // 2\r\n  上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。\r\n\r\n  不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。\r\n\r\n  实例方法：includes(), startsWith(), endsWith()\r\n  传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\r\n\r\n  includes()：返回布尔值，表示是否找到了参数字符串。\r\n  startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\r\n  endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\r\n  let s = 'Hello world!';\r\n\r\n  s.startsWith('Hello') // true\r\n  s.endsWith('!') // true\r\n  s.includes('o') // true\r\n  这三个方法都支持第二个参数，表示开始搜索的位置。\r\n\r\n  let s = 'Hello world!';\r\n\r\n  s.startsWith('world', 6) // true\r\n  s.endsWith('Hello', 5) // true\r\n  s.includes('Hello', 6) // false\r\n  上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\r\n\r\n  实例方法：repeat()\r\n  repeat方法返回一个新字符串，表示将原字符串重复n次。\r\n\r\n  'x'.repeat(3) // \"xxx\"\r\n  'hello'.repeat(2) // \"hellohello\"\r\n  'na'.repeat(0) // \"\"\r\n  参数如果是小数，会被取整。\r\n\r\n  'na'.repeat(2.9) // \"nana\"\r\n  如果repeat的参数是负数或者Infinity，会报错。\r\n\r\n  'na'.repeat(Infinity)\r\n  // RangeError\r\n  'na'.repeat(-1)\r\n  // RangeError\r\n  但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。\r\n\r\n  'na'.repeat(-0.9) // \"\"\r\n  参数NaN等同于 0。\r\n\r\n  'na'.repeat(NaN) // \"\"\r\n  如果repeat的参数是字符串，则会先转换成数字。\r\n\r\n  'na'.repeat('na') // \"\"\r\n  'na'.repeat('3') // \"nanana\"\r\n  实例方法：padStart()，padEnd()\r\n  ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。\r\n\r\n  'x'.padStart(5, 'ab') // 'ababx'\r\n  'x'.padStart(4, 'ab') // 'abax'\r\n\r\n  'x'.padEnd(5, 'ab') // 'xabab'\r\n  'x'.padEnd(4, 'ab') // 'xaba'\r\n  上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。\r\n\r\n  如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。\r\n\r\n  'xxx'.padStart(2, 'ab') // 'xxx'\r\n  'xxx'.padEnd(2, 'ab') // 'xxx'\r\n  如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。\r\n\r\n  'abc'.padStart(10, '0123456789')\r\n  // '0123456abc'\r\n  如果省略第二个参数，默认使用空格补全长度。\r\n\r\n  'x'.padStart(4) // '   x'\r\n  'x'.padEnd(4) // 'x   '\r\n  padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。\r\n\r\n  '1'.padStart(10, '0') // \"0000000001\"\r\n  '12'.padStart(10, '0') // \"0000000012\"\r\n  '123456'.padStart(10, '0') // \"0000123456\"\r\n  另一个用途是提示字符串格式。\r\n\r\n  '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"\r\n  '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"\r\n  实例方法：trimStart()，trimEnd()\r\n  ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\r\n\r\n  const s = '  abc  ';\r\n\r\n  s.trim() // \"abc\"\r\n  s.trimStart() // \"abc  \"\r\n  s.trimEnd() // \"  abc\"\r\n  上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。\r\n\r\n  除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。\r\n\r\n  浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。\r\n\r\n  实例方法：matchAll()\r\n  matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。\r\n</pre>\r\n</div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: '03String'\r\n}\r\n</script>\r\n\r\n<style lang=\"stylus\" scoped></style>\r\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./03String.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./03String.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./03String.vue?vue&type=template&id=5f646090&scoped=true&\"\nimport script from \"./03String.vue?vue&type=script&lang=js&\"\nexport * from \"./03String.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"5f646090\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}